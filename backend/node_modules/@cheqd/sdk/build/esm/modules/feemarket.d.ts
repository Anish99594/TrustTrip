import { GasPriceResponse, GasPricesResponse, ParamsResponse } from '@cheqd/ts-proto/feemarket/feemarket/v1/index.js';
import { EncodeObject, GeneratedType } from '@cosmjs/proto-signing';
import { GasPrice, QueryClient } from '@cosmjs/stargate';
import { AbstractCheqdSDKModule, MinimalImportableCheqdSDKModule } from './_.js';
import { DidStdFee, IContext, QueryExtensionSetup } from '../types.js';
import { CheqdQuerier } from '../querier.js';
import { CheqdSigningStargateClient } from '../signer.js';
export declare const defaultFeemarketExtensionKey: "feemarket";
export declare const protobufLiterals: {
    readonly GasPriceResponse: "GasPriceResponse";
    readonly GasPricesResponse: "GasPricesResponse";
    readonly ParamsResponse: "ParamsResponse";
};
export declare const typeUrlGasPriceResponse: "/feemarket.feemarket.v1.GasPriceResponse";
export declare const typeUrlGasPricesResponse: "/feemarket.feemarket.v1.GasPricesResponse";
export declare const typeUrlParamsResponse: "/feemarket.feemarket.v1.ParamsResponse";
export declare const defaultGasPriceTiers: {
    readonly Low: "DefaultLowTier";
    readonly Avg: "DefaultAvgTier";
    readonly High: "DefaultHighTier";
};
export type DefaultGasPriceTiers = (typeof defaultGasPriceTiers)[keyof typeof defaultGasPriceTiers];
export interface GasPriceEncodeObject extends EncodeObject {
    readonly typeUrl: typeof typeUrlGasPriceResponse;
    readonly value: Partial<GasPriceResponse>;
}
export declare function isGasPriceEncodeObject(obj: EncodeObject): obj is GasPriceEncodeObject;
export interface GasPricesEncodeObject extends EncodeObject {
    readonly typeUrl: typeof typeUrlGasPricesResponse;
    readonly value: Partial<GasPricesResponse>;
}
export declare function isGasPricesEncodeObject(obj: EncodeObject): obj is GasPricesEncodeObject;
export interface ParamsEncodeObject extends EncodeObject {
    readonly typeUrl: typeof typeUrlParamsResponse;
    readonly value: Partial<ParamsResponse>;
}
export declare function isParamsEncodeObject(obj: EncodeObject): obj is ParamsEncodeObject;
export type MinimalImportableFeemarketModule = MinimalImportableCheqdSDKModule<FeemarketModule>;
export type FeemarketExtension = {
    readonly [defaultFeemarketExtensionKey]: {
        readonly gasPrice: (denom: string) => Promise<GasPriceResponse>;
        readonly gasPrices: () => Promise<GasPricesResponse>;
        readonly params: () => Promise<ParamsResponse>;
    };
};
export declare const setupFeemarketExtension: (base: QueryClient) => FeemarketExtension;
export declare class FeemarketModule extends AbstractCheqdSDKModule {
    static readonly registryTypes: Iterable<[string, GeneratedType]>;
    static readonly defaultGasPrices: {
        readonly DefaultLowTier: {
            readonly amount: "5000";
            readonly denom: "ncheq";
        };
        readonly DefaultAvgTier: {
            readonly amount: "7500";
            readonly denom: "ncheq";
        };
        readonly DefaultHighTier: {
            readonly amount: "10000";
            readonly denom: "ncheq";
        };
    };
    static readonly gasOffsetFactor: number;
    static readonly feeCollectorAddress: "cheqd13pxn9n3qw79e03844rdadagmg0nshmwfszqu0g";
    static readonly moduleAccountAddress: "cheqd1el68mjnzv87uurqks8u29tec0cj3297047g2dl";
    static readonly querierExtensionSetup: QueryExtensionSetup<FeemarketExtension>;
    querier: CheqdQuerier & FeemarketExtension;
    constructor(signer: CheqdSigningStargateClient, querier: CheqdQuerier & FeemarketExtension);
    getRegistryTypes(): Iterable<[string, GeneratedType]>;
    getQuerierExtensionSetup(): QueryExtensionSetup<FeemarketExtension>;
    queryGasPrice(denom: string, context?: IContext): Promise<GasPriceResponse>;
    queryGasPrices(context?: IContext): Promise<GasPricesResponse>;
    queryParams(context?: IContext): Promise<ParamsResponse>;
    /**
     * Generate gas price by denom by live polling. If live poll fails, the error is bubbled up.
     * @param denom
     * @returns GasPrice
     */
    generateGasPrice(denom: string, context?: IContext): Promise<GasPrice>;
    /**
     * Generate offline gas price by denom by static tier.
     * @param denom
     * @param tier
     * @returns GasPrice
     */
    generateOfflineGasPrice(denom: string, tier?: DefaultGasPriceTiers): Promise<GasPrice>;
    /**
     * Generate safe gas price by denom by live polling with fallback to offline gas price. If live poll fails, the error is caught and offline gas price is generated.
     * @param denom
     * @param tier
     * @returns GasPrice
     */
    generateSafeGasPrice(denom: string, tier?: DefaultGasPriceTiers, context?: IContext): Promise<GasPrice>;
    /**
     * Generate safe gas price by denom by live polling with exponential backoff to offline gas price.
     * @param denom
     * @param tier
     * @param backoffOptions
     * @returns GasPrice
     */
    generateSafeGasPriceWithExponentialBackoff(denom: string, tier?: DefaultGasPriceTiers, backoffOptions?: Partial<import("exponential-backoff").IBackOffOptions>, context?: IContext): Promise<GasPrice>;
    /**
     * Generate fees from gas price. Use with live polling for gas price.
     * @param gasPrice
     * @param payer
     * @param gas
     * @returns DidStdFee
     */
    static generateFeesFromGasPrice(gasPrice: GasPrice, payer: string, gas?: string): DidStdFee;
}
//# sourceMappingURL=feemarket.d.ts.map