import { AbstractCheqdSDKModule } from './_.js';
import { CheqdSigningStargateClient } from '../signer.js';
import { ISignInputs } from '../types.js';
import { MsgCreateResource, MsgCreateResourcePayload, MsgCreateResourceResponse, QueryClientImpl, protobufPackage, } from '@cheqd/ts-proto/cheqd/resource/v2/index.js';
import { createPagination, createProtobufRpcClient } from '@cosmjs/stargate';
import { fileTypeFromBuffer } from 'file-type';
import { toString } from 'uint8arrays/to-string';
import { assert } from '@cosmjs/utils';
import { isJSON } from '../utils.js';
export const defaultResourceExtensionKey = 'resource';
export const protobufLiterals = {
    MsgCreateResource: 'MsgCreateResource',
    MsgCreateResourceResponse: 'MsgCreateResourceResponse',
};
export const typeUrlMsgCreateResource = `/${protobufPackage}.${protobufLiterals.MsgCreateResource}`;
export const typeUrlMsgCreateResourceResponse = `/${protobufPackage}.${protobufLiterals.MsgCreateResourceResponse}`;
export function isMsgCreateResourceEncodeObject(obj) {
    return obj.typeUrl === typeUrlMsgCreateResource;
}
export const setupResourceExtension = (base) => {
    const rpc = createProtobufRpcClient(base);
    const queryService = new QueryClientImpl(rpc);
    return {
        [defaultResourceExtensionKey]: {
            resource: async (collectionId, resourceId) => {
                const { resource } = await queryService.Resource({ collectionId, id: resourceId });
                assert(resource);
                return resource;
            },
            resourceMetadata: async (collectionId, resourceId) => {
                const { resource } = await queryService.ResourceMetadata({ collectionId, id: resourceId });
                assert(resource);
                return resource;
            },
            collectionResources: async (collectionId, paginationKey) => {
                const response = await queryService.CollectionResources({
                    collectionId,
                    pagination: createPagination(paginationKey),
                });
                return response;
            },
        },
    };
};
export class ResourceModule extends AbstractCheqdSDKModule {
    // @ts-expect-error underlying type `GeneratedType` is intentionally wider
    static registryTypes = [
        [typeUrlMsgCreateResource, MsgCreateResource],
        [typeUrlMsgCreateResourceResponse, MsgCreateResourceResponse],
    ];
    static baseMinimalDenom = 'ncheq';
    static fees = {
        DefaultCreateResourceImageFee: { amount: '10000000000', denom: ResourceModule.baseMinimalDenom },
        DefaultCreateResourceJsonFee: { amount: '10000000000', denom: ResourceModule.baseMinimalDenom },
        DefaultCreateResourceDefaultFee: { amount: '10000000000', denom: ResourceModule.baseMinimalDenom },
    };
    static querierExtensionSetup = setupResourceExtension;
    querier;
    constructor(signer, querier) {
        super(signer, querier);
        this.querier = querier;
        this.methods = {
            createLinkedResourceTx: this.createLinkedResourceTx.bind(this),
            queryLinkedResource: this.queryLinkedResource.bind(this),
            queryLinkedResourceMetadata: this.queryLinkedResourceMetadata.bind(this),
            queryLinkedResources: this.queryLinkedResources.bind(this),
        };
    }
    getRegistryTypes() {
        return ResourceModule.registryTypes;
    }
    getQuerierExtensionSetup() {
        return ResourceModule.querierExtensionSetup;
    }
    static async signPayload(payload, signInputs) {
        const signBytes = MsgCreateResourcePayload.encode(payload).finish();
        let signatures;
        if (ISignInputs.isSignInput(signInputs)) {
            signatures = await CheqdSigningStargateClient.signIdentityTx(signBytes, signInputs);
        }
        else {
            signatures = signInputs;
        }
        return {
            payload,
            signatures,
        };
    }
    async createLinkedResourceTx(signInputs, resourcePayload, address, fee, memo, context) {
        if (!this._signer) {
            this._signer = context.sdk.signer;
        }
        const payload = MsgCreateResourcePayload.fromPartial(resourcePayload);
        const msg = await ResourceModule.signPayload(payload, signInputs);
        const encObj = {
            typeUrl: typeUrlMsgCreateResource,
            value: msg,
        };
        if (address === '') {
            address = (await context.sdk.options.wallet.getAccounts())[0].address;
        }
        if (!fee) {
            if (payload.data.length === 0) {
                throw new Error('Linked resource data is empty');
            }
            fee = await (async function () {
                const mimeType = await ResourceModule.readMimeType(payload.data);
                if (mimeType.startsWith('image/')) {
                    return await ResourceModule.generateCreateResourceImageFees(address);
                }
                if (mimeType.startsWith('application/json')) {
                    return await ResourceModule.generateCreateResourceJsonFees(address);
                }
                return await ResourceModule.generateCreateResourceDefaultFees(address);
            })();
        }
        return this._signer.signAndBroadcast(address, [encObj], fee, memo);
    }
    async queryLinkedResource(collectionId, resourceId, context) {
        if (!this.querier) {
            this.querier = context.sdk.querier;
        }
        return await this.querier[defaultResourceExtensionKey].resource(collectionId, resourceId);
    }
    async queryLinkedResourceMetadata(collectionId, resourceId, context) {
        if (!this.querier) {
            this.querier = context.sdk.querier;
        }
        return await this.querier[defaultResourceExtensionKey].resourceMetadata(collectionId, resourceId);
    }
    async queryLinkedResources(collectionId, context) {
        if (!this.querier) {
            this.querier = context.sdk.querier;
        }
        return await this.querier[defaultResourceExtensionKey].collectionResources(collectionId);
    }
    static async readMimeType(content) {
        if (isJSON(toString(content, 'utf-8')))
            return 'application/json';
        return (await fileTypeFromBuffer(content))?.mime ?? 'application/octet-stream';
    }
    static async generateCreateResourceImageFees(feePayer, granter) {
        return {
            amount: [ResourceModule.fees.DefaultCreateResourceImageFee],
            gas: '2000000',
            payer: feePayer,
            granter: granter,
        };
    }
    static async generateCreateResourceJsonFees(feePayer, granter) {
        return {
            amount: [ResourceModule.fees.DefaultCreateResourceJsonFee],
            gas: '2000000',
            payer: feePayer,
            granter: granter,
        };
    }
    static async generateCreateResourceDefaultFees(feePayer, granter) {
        return {
            amount: [ResourceModule.fees.DefaultCreateResourceDefaultFee],
            gas: '2000000',
            payer: feePayer,
            granter: granter,
        };
    }
}
//# sourceMappingURL=resource.js.map