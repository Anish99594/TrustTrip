"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceModule = exports.setupResourceExtension = exports.typeUrlMsgCreateResourceResponse = exports.typeUrlMsgCreateResource = exports.protobufLiterals = exports.defaultResourceExtensionKey = void 0;
exports.isMsgCreateResourceEncodeObject = isMsgCreateResourceEncodeObject;
const _1 = require("./_");
const signer_1 = require("../signer");
const types_1 = require("../types");
const v2_1 = require("@cheqd/ts-proto-cjs/cheqd/resource/v2");
const stargate_cjs_1 = require("@cosmjs/stargate-cjs");
const uint8arrays_cjs_1 = require("uint8arrays-cjs");
const browser_1 = require("file-type-cjs/browser");
const utils_cjs_1 = require("@cosmjs/utils-cjs");
const utils_1 = require("../utils");
exports.defaultResourceExtensionKey = 'resource';
exports.protobufLiterals = {
    MsgCreateResource: 'MsgCreateResource',
    MsgCreateResourceResponse: 'MsgCreateResourceResponse',
};
exports.typeUrlMsgCreateResource = `/${v2_1.protobufPackage}.${exports.protobufLiterals.MsgCreateResource}`;
exports.typeUrlMsgCreateResourceResponse = `/${v2_1.protobufPackage}.${exports.protobufLiterals.MsgCreateResourceResponse}`;
function isMsgCreateResourceEncodeObject(obj) {
    return obj.typeUrl === exports.typeUrlMsgCreateResource;
}
const setupResourceExtension = (base) => {
    const rpc = (0, stargate_cjs_1.createProtobufRpcClient)(base);
    const queryService = new v2_1.QueryClientImpl(rpc);
    return {
        [exports.defaultResourceExtensionKey]: {
            resource: async (collectionId, resourceId) => {
                const { resource } = await queryService.Resource({
                    collectionId,
                    id: resourceId,
                });
                (0, utils_cjs_1.assert)(resource);
                return resource;
            },
            resourceMetadata: async (collectionId, resourceId) => {
                const { resource } = await queryService.ResourceMetadata({
                    collectionId,
                    id: resourceId,
                });
                (0, utils_cjs_1.assert)(resource);
                return resource;
            },
            collectionResources: async (collectionId, paginationKey) => {
                const response = await queryService.CollectionResources({
                    collectionId,
                    pagination: (0, stargate_cjs_1.createPagination)(paginationKey),
                });
                return response;
            },
        },
    };
};
exports.setupResourceExtension = setupResourceExtension;
class ResourceModule extends _1.AbstractCheqdSDKModule {
    //@ts-expect-error the underlying type is intentionally wider
    static registryTypes = [
        [exports.typeUrlMsgCreateResource, v2_1.MsgCreateResource],
        [exports.typeUrlMsgCreateResourceResponse, v2_1.MsgCreateResourceResponse],
    ];
    static baseMinimalDenom = 'ncheq';
    static fees = {
        DefaultCreateResourceImageFee: {
            amount: '10000000000',
            denom: ResourceModule.baseMinimalDenom,
        },
        DefaultCreateResourceJsonFee: {
            amount: '10000000000',
            denom: ResourceModule.baseMinimalDenom,
        },
        DefaultCreateResourceDefaultFee: {
            amount: '10000000000',
            denom: ResourceModule.baseMinimalDenom,
        },
    };
    static querierExtensionSetup = exports.setupResourceExtension;
    querier;
    constructor(signer, querier) {
        super(signer, querier);
        this.querier = querier;
        this.methods = {
            createLinkedResourceTx: this.createLinkedResourceTx.bind(this),
            queryLinkedResource: this.queryLinkedResource.bind(this),
            queryLinkedResourceMetadata: this.queryLinkedResourceMetadata.bind(this),
            queryLinkedResources: this.queryLinkedResources.bind(this),
        };
    }
    getRegistryTypes() {
        return ResourceModule.registryTypes;
    }
    getQuerierExtensionSetup() {
        return ResourceModule.querierExtensionSetup;
    }
    static async signPayload(payload, signInputs) {
        const signBytes = v2_1.MsgCreateResourcePayload.encode(payload).finish();
        let signatures;
        if (types_1.ISignInputs.isSignInput(signInputs)) {
            signatures = await signer_1.CheqdSigningStargateClient.signIdentityTx(signBytes, signInputs);
        }
        else {
            signatures = signInputs;
        }
        return {
            payload,
            signatures,
        };
    }
    async createLinkedResourceTx(signInputs, resourcePayload, address, fee, memo, context) {
        if (!this._signer) {
            this._signer = context.sdk.signer;
        }
        const payload = v2_1.MsgCreateResourcePayload.fromPartial(resourcePayload);
        const msg = await ResourceModule.signPayload(payload, signInputs);
        const encObj = {
            typeUrl: exports.typeUrlMsgCreateResource,
            value: msg,
        };
        if (address === '') {
            address = (await context.sdk.options.wallet.getAccounts())[0].address;
        }
        if (!fee) {
            if (payload.data.length === 0) {
                throw new Error('Linked resource data is empty');
            }
            fee = await (async function () {
                const mimeType = await ResourceModule.readMimeType(payload.data);
                if (mimeType.startsWith('image/')) {
                    return await ResourceModule.generateCreateResourceImageFees(address);
                }
                if (mimeType.startsWith('application/json')) {
                    return await ResourceModule.generateCreateResourceJsonFees(address);
                }
                return await ResourceModule.generateCreateResourceDefaultFees(address);
            })();
        }
        return this._signer.signAndBroadcast(address, [encObj], fee, memo);
    }
    async queryLinkedResource(collectionId, resourceId, context) {
        if (!this.querier) {
            this.querier = context.sdk.querier;
        }
        return await this.querier[exports.defaultResourceExtensionKey].resource(collectionId, resourceId);
    }
    async queryLinkedResourceMetadata(collectionId, resourceId, context) {
        if (!this.querier) {
            this.querier = context.sdk.querier;
        }
        return await this.querier[exports.defaultResourceExtensionKey].resourceMetadata(collectionId, resourceId);
    }
    async queryLinkedResources(collectionId, context) {
        if (!this.querier) {
            this.querier = context.sdk.querier;
        }
        return await this.querier[exports.defaultResourceExtensionKey].collectionResources(collectionId);
    }
    static async readMimeType(content) {
        if ((0, utils_1.isJSON)((0, uint8arrays_cjs_1.toString)(content, 'utf-8')))
            return 'application/json';
        return (await (0, browser_1.fromBuffer)(content))?.mime ?? 'application/octet-stream';
    }
    static async generateCreateResourceImageFees(feePayer, granter) {
        return {
            amount: [ResourceModule.fees.DefaultCreateResourceImageFee],
            gas: '2000000',
            payer: feePayer,
            granter: granter,
        };
    }
    static async generateCreateResourceJsonFees(feePayer, granter) {
        return {
            amount: [ResourceModule.fees.DefaultCreateResourceJsonFee],
            gas: '2000000',
            payer: feePayer,
            granter: granter,
        };
    }
    static async generateCreateResourceDefaultFees(feePayer, granter) {
        return {
            amount: [ResourceModule.fees.DefaultCreateResourceDefaultFee],
            gas: '2000000',
            payer: feePayer,
            granter: granter,
        };
    }
}
exports.ResourceModule = ResourceModule;
//# sourceMappingURL=resource.js.map