"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeemarketModule = exports.setupFeemarketExtension = exports.defaultGasPriceTiers = exports.typeUrlParamsResponse = exports.typeUrlGasPricesResponse = exports.typeUrlGasPriceResponse = exports.protobufLiterals = exports.defaultFeemarketExtensionKey = void 0;
exports.isGasPriceEncodeObject = isGasPriceEncodeObject;
exports.isGasPricesEncodeObject = isGasPricesEncodeObject;
exports.isParamsEncodeObject = isParamsEncodeObject;
const index_js_1 = require("@cheqd/ts-proto-cjs/feemarket/feemarket/v1/index.js");
const stargate_cjs_1 = require("@cosmjs/stargate-cjs");
const _1 = require("./_");
const utils_1 = require("../utils");
const math_cjs_1 = require("@cosmjs/math-cjs");
exports.defaultFeemarketExtensionKey = 'feemarket';
exports.protobufLiterals = {
    GasPriceResponse: 'GasPriceResponse',
    GasPricesResponse: 'GasPricesResponse',
    ParamsResponse: 'ParamsResponse',
};
exports.typeUrlGasPriceResponse = `/${index_js_1.protobufPackage}.${exports.protobufLiterals.GasPriceResponse}`;
exports.typeUrlGasPricesResponse = `/${index_js_1.protobufPackage}.${exports.protobufLiterals.GasPricesResponse}`;
exports.typeUrlParamsResponse = `/${index_js_1.protobufPackage}.${exports.protobufLiterals.ParamsResponse}`;
exports.defaultGasPriceTiers = {
    Low: 'DefaultLowTier',
    Avg: 'DefaultAvgTier',
    High: 'DefaultHighTier',
};
function isGasPriceEncodeObject(obj) {
    return obj.typeUrl === exports.typeUrlGasPriceResponse;
}
function isGasPricesEncodeObject(obj) {
    return obj.typeUrl === exports.typeUrlGasPricesResponse;
}
function isParamsEncodeObject(obj) {
    return obj.typeUrl === exports.typeUrlParamsResponse;
}
const setupFeemarketExtension = (base) => {
    const rpc = (0, stargate_cjs_1.createProtobufRpcClient)(base);
    const queryService = new index_js_1.QueryClientImpl(rpc);
    return {
        [exports.defaultFeemarketExtensionKey]: {
            gasPrice: async (denom) => {
                return queryService.GasPrice({ denom });
            },
            gasPrices: async () => {
                return queryService.GasPrices({});
            },
            params: async () => {
                return queryService.Params({});
            },
        },
    };
};
exports.setupFeemarketExtension = setupFeemarketExtension;
class FeemarketModule extends _1.AbstractCheqdSDKModule {
    // @ts-expect-error underlying type `GeneratedType` is intentionally wider
    static registryTypes = [
        [exports.typeUrlGasPriceResponse, index_js_1.GasPriceResponse],
        [exports.typeUrlGasPricesResponse, index_js_1.GasPricesResponse],
        [exports.typeUrlParamsResponse, index_js_1.ParamsResponse],
    ];
    static defaultGasPrices = {
        [exports.defaultGasPriceTiers.Low]: { amount: '5000', denom: 'ncheq' },
        [exports.defaultGasPriceTiers.Avg]: { amount: '7500', denom: 'ncheq' },
        [exports.defaultGasPriceTiers.High]: { amount: '10000', denom: 'ncheq' },
    };
    static gasOffsetFactor = 10 ** 4;
    static feeCollectorAddress = 'cheqd13pxn9n3qw79e03844rdadagmg0nshmwfszqu0g';
    static moduleAccountAddress = 'cheqd1el68mjnzv87uurqks8u29tec0cj3297047g2dl';
    static querierExtensionSetup = exports.setupFeemarketExtension;
    querier;
    constructor(signer, querier) {
        super(signer, querier);
        this.querier = querier;
        this.methods = {
            queryGasPrice: this.queryGasPrice.bind(this),
            queryGasPrices: this.queryGasPrices.bind(this),
            queryParams: this.queryParams.bind(this),
            generateGasPrice: this.generateGasPrice.bind(this),
            generateOfflineGasPrice: this.generateOfflineGasPrice.bind(this),
            generateSafeGasPrice: this.generateSafeGasPrice.bind(this),
            generateSafeGasPriceWithExponentialBackoff: this.generateSafeGasPriceWithExponentialBackoff.bind(this),
        };
    }
    getRegistryTypes() {
        return FeemarketModule.registryTypes;
    }
    getQuerierExtensionSetup() {
        return FeemarketModule.querierExtensionSetup;
    }
    async queryGasPrice(denom, context) {
        if (!this.querier)
            this.querier = context.sdk.querier;
        return this.querier[exports.defaultFeemarketExtensionKey].gasPrice(denom);
    }
    async queryGasPrices(context) {
        if (!this.querier)
            this.querier = context.sdk.querier;
        return this.querier[exports.defaultFeemarketExtensionKey].gasPrices();
    }
    async queryParams(context) {
        if (!this.querier)
            this.querier = context.sdk.querier;
        return this.querier[exports.defaultFeemarketExtensionKey].params();
    }
    /**
     * Generate gas price by denom by live polling. If live poll fails, the error is bubbled up.
     * @param denom
     * @returns GasPrice
     */
    async generateGasPrice(denom, context) {
        if (!this.querier)
            this.querier = context.sdk.querier;
        // query gas price, bubble up error, no catch
        const gasPrice = await this.queryGasPrice(denom, context);
        // validate gas price
        if (!gasPrice.price)
            throw new Error('Invalid gas price: live poll for gas price failed');
        // convert gas price through offset factor
        const adjustedGasPrice = math_cjs_1.Decimal.fromAtomics(gasPrice.price.amount, 18)
            .multiply(math_cjs_1.Uint32.fromString(FeemarketModule.gasOffsetFactor.toString()))
            .toString();
        // safe convert gas price to string
        return stargate_cjs_1.GasPrice.fromString(`${adjustedGasPrice}${gasPrice.price.denom}`);
    }
    /**
     * Generate offline gas price by denom by static tier.
     * @param denom
     * @param tier
     * @returns GasPrice
     */
    async generateOfflineGasPrice(denom, tier = exports.defaultGasPriceTiers.Low) {
        // validate denom against default
        if (!Object.values(FeemarketModule.defaultGasPrices).some((gp) => gp.denom === denom))
            throw new Error(`Invalid denom: ${denom}`);
        // validate tier against default
        if (!Object.keys(FeemarketModule.defaultGasPrices).includes(tier))
            throw new Error(`Invalid tier: ${tier}`);
        // generate gas price
        const gasPrice = FeemarketModule.defaultGasPrices[tier];
        // safe convert gas price to string
        return stargate_cjs_1.GasPrice.fromString(`${gasPrice.amount}${gasPrice.denom}`);
    }
    /**
     * Generate safe gas price by denom by live polling with fallback to offline gas price. If live poll fails, the error is caught and offline gas price is generated.
     * @param denom
     * @param tier
     * @returns GasPrice
     */
    async generateSafeGasPrice(denom, tier = exports.defaultGasPriceTiers.Low, context) {
        if (!this.querier)
            this.querier = context.sdk.querier;
        try {
            // generate gas price
            return await this.generateGasPrice(denom, context);
        }
        catch (error) {
            // generate offline gas price
            return await this.generateOfflineGasPrice(denom, tier);
        }
    }
    /**
     * Generate safe gas price by denom by live polling with exponential backoff to offline gas price.
     * @param denom
     * @param tier
     * @param backoffOptions
     * @returns GasPrice
     */
    async generateSafeGasPriceWithExponentialBackoff(denom, tier = exports.defaultGasPriceTiers.Low, backoffOptions = utils_1.DefaultBackoffOptions, context) {
        if (!this.querier)
            this.querier = context.sdk.querier;
        // live poll for gas price
        const gasPrice = await (0, utils_1.retry)(() => this.generateGasPrice(denom, context), backoffOptions);
        // return, if applicable
        if (gasPrice)
            return gasPrice;
        // otherwise, generate offline gas price
        return await this.generateOfflineGasPrice(denom, tier);
    }
    /**
     * Generate fees from gas price. Use with live polling for gas price.
     * @param gasPrice
     * @param payer
     * @param gas
     * @returns DidStdFee
     */
    static generateFeesFromGasPrice(gasPrice, payer, gas = '200000') {
        return {
            amount: [{ denom: gasPrice.denom, amount: gasPrice.amount.multiply(math_cjs_1.Uint32.fromString(gas)).toString() }],
            gas,
            payer,
        };
    }
}
exports.FeemarketModule = FeemarketModule;
//# sourceMappingURL=feemarket.js.map